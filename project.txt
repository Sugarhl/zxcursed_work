Contents of models.py:
  from sqlalchemy import Column, Integer, LargeBinary, String, ForeignKey, CheckConstraint, DateTime
  from sqlalchemy.orm import relationship
  from server.database import Base
  from sqlalchemy import Column, Integer, String, ForeignKey, CheckConstraint, DateTime
  from server.database import Base
  
  
  class Lab(Base):
      __tablename__ = "lab"
      id = Column(Integer, primary_key=True, index=True)
      lab_name = Column(String(255), nullable=False)
      description = Column(String)
      owner = Column(String(255), nullable=False)
      file_of_lab = Column(String)
  
  
  class Tutor(Base):
      __tablename__ = "tutor"
      id = Column(Integer, primary_key=True, index=True)
      first_name = Column(String(255), nullable=False)
      last_name = Column(String(255), nullable=False)
      email = Column(String(255), nullable=False, unique=True)
  
  
  class Student(Base):
      __tablename__ = "student"
      id = Column(Integer, primary_key=True, index=True)
      first_name = Column(String(255), nullable=False)
      last_name = Column(String(255), nullable=False)
      email = Column(String(255), nullable=False, unique=True)
  
  
  class User(Base):
      __tablename__ = "login_creds"
      id = Column(Integer, primary_key=True, index=True)
      user_id = Column(Integer, nullable=False)
      user_type = Column(String(50), nullable=False, index=True)
      username = Column(String(255), nullable=False, unique=True)
      password = Column(String(255), nullable=False)
      salt = Column(String(255), nullable=False)
      CheckConstraint("user_type IN ('Student', 'Tutor')")
  
  
  class LabVariant(Base):
      __tablename__ = "lab_var"
      id = Column(Integer, primary_key=True, index=True)
      lab_id = Column(Integer, ForeignKey(
          "lab.id", ondelete="CASCADE"), nullable=False)
      variant_name = Column(String(255), nullable=False)
      description = Column(String)
  
  
  class LabSolution(Base):
      __tablename__ = "lab_solution"
      id = Column(Integer, primary_key=True, index=True)
      lab_variant_id = Column(Integer, ForeignKey(
          "lab_var.id", ondelete="CASCADE"), nullable=False)
      student_id = Column(Integer, ForeignKey(
          "student.id", ondelete="CASCADE"), nullable=False)
      tutor_id = Column(Integer, ForeignKey(
          "tutor.id", ondelete="CASCADE"), nullable=False)
      solution_filename = Column(String)
      file_data = Column(LargeBinary)
      mark = Column(Integer)
  
  
  class LabSolutionComment(Base):
      __tablename__ = "lab_solution_comment"
      id = Column(Integer, primary_key=True, index=True)
      solution_id = Column(Integer, ForeignKey(
          "lab_solution.id", ondelete="CASCADE"), nullable=False)
      user_id = Column(Integer, ForeignKey(
          "login_creds.id", ondelete="CASCADE"), nullable=False)
      user_type = Column(String(50), nullable=False, index=True)
      comment_text = Column(String)
      created_date = Column(DateTime)
  
  
  class LabResult(Base):
      __tablename__ = "lab_result"
      id = Column(Integer, primary_key=True, index=True)
      student_id = Column(Integer, ForeignKey(
          "student.id", ondelete="CASCADE"), nullable=False)
      lab_variant_id = Column(Integer, ForeignKey(
          "lab_var.id", ondelete="CASCADE"), nullable=False)
      score = Column(Integer)
      submission_date = Column(DateTime)
  
  
  # Lab table relationships
  Lab.variants = relationship(
      "LabVariant", order_by=LabVariant.id, back_populates="lab")
  
  # LabVariant table relationships
  LabVariant.lab = relationship(
      "Lab", back_populates="variants")
  LabVariant.solutions = relationship(
      "LabSolution", order_by=LabSolution.id, back_populates="lab_variant")
  
  # LabSolution table relationships
  LabSolution.lab_variant = relationship(
      "LabVariant", back_populates="solutions")
  LabSolution.student = relationship(
      "Student", back_populates="solutions")
  LabSolution.tutor = relationship(
      "Tutor", back_populates="solutions")
  LabSolution.comments = relationship(
      "LabSolutionComment", back_populates="solution")
  
  # LabSolutionComment table relationships
  LabSolutionComment.solution = relationship(
      "LabSolution", back_populates="comments")
  LabSolutionComment.user = relationship(
      "User", back_populates="comments")
  
  # Student table relationships
  Student.solutions = relationship(
      "LabSolution", order_by=LabSolution.id, back_populates="student")
  Student.lab_results = relationship(
      "LabResult",  cascade="save-update, merge, delete, delete-orphan", order_by=LabResult.id, back_populates="student")
  
  # Tutor table relationships
  Tutor.solutions = relationship(
      "LabSolution", order_by=LabSolution.id, back_populates="tutor")
  
  # User table relationships
  User.comments = relationship(
      "LabSolutionComment", order_by=LabSolutionComment.id, back_populates="user")

Contents of api/login.py:
  import datetime
  from typing import Union
  from fastapi_security import Dict
  import jwt
  from fastapi import APIRouter, Depends, HTTPException, status
  from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
  from pydantic import ValidationError
  from sqlalchemy.ext.asyncio import AsyncSession
  from datetime import timedelta
  from jwt import decode, ExpiredSignatureError, InvalidTokenError
  
  import server.schemas as schemas
  from server.models import User
  from server.crud import get_user_by_id, get_user_by_username, verify_password
  from server.database import get_db
  from server.config import SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES
  
  router = APIRouter()
  
  oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")
  
  
  def create_access_token(user_id: int, user_type: str):
      expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES).total_seconds()
      to_encode = {"user_id": user_id, "user_type": user_type, "exp": expire}
      encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
      return encoded_jwt
  
  
  async def authenticate_user(db: AsyncSession, username: str, password: str):
      user = await get_user_by_username(db, username)
      if not user:
          return False
      if not verify_password(password, user.salt, user.password):
          return False
      return user
  
  
  def decode_access_token(token: str) -> Dict[str, Union[int, str]]:
      try:
          payload = decode(token, SECRET_KEY, algorithms=[ALGORITHM])
          return payload
      except ExpiredSignatureError:
          raise HTTPException(
              status_code=status.HTTP_401_UNAUTHORIZED, detail="Token has expired")
      except InvalidTokenError:
          raise HTTPException(
              status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
  
  
  @router.post("/token", response_model=schemas.Token)
  async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)):
      user = await authenticate_user(db, form_data.username, form_data.password)
      if not user:
          raise HTTPException(
              status_code=status.HTTP_400_BAD_REQUEST, detail="Incorrect username or password")
      access_token = create_access_token(user.id, user.user_type)
      return {"access_token": access_token, "token_type": "bearer"}


Contents of main.py:
  from fastapi import FastAPI
  from server.database import async_engine, Base, async_database
  
  from server.api.login import router as login_router
  from server.api.registration import router as registration_router
  from server.api.solutions import router as solutions_router
  
  app = FastAPI()
  
  @app.on_event("startup")
  async def startup():
      async with async_engine.begin() as conn:
          # await conn.run_sync(Base.metadata.drop_all)
          await conn.run_sync(Base.metadata.create_all)
      await async_database.connect()
  
  @app.on_event("shutdown")
  async def shutdown():
      await async_database.disconnect()
  
  app.include_router(login_router, prefix="/auth", tags=["Authentication"])
  app.include_router(registration_router, prefix="/registration", tags=["Registration"])
  app.include_router(solutions_router, prefix="/solutions", tags=["Solutions"])
  
  @app.get("/")
  async def root():
      return {"message": "Welcome!"}

Contents of crud.py:
  from typing import Optional
  import bcrypt
  from fastapi import UploadFile
  from sqlalchemy.ext.asyncio import AsyncSession
  from sqlalchemy.future import select
  
  import server.models as models
  import server.schemas as schemas
  
  
  # Some utils
  def generate_salt() -> str:
      return bcrypt.gensalt().decode("utf-8")
  
  
  # Create statements
  async def create_user(db: AsyncSession,
                        user_in: schemas.UserIn,
                        user_type: str,
                        user_id: int) -> int:
      salt = generate_salt()
      hashed_password = bcrypt.hashpw(
          user_in.password.encode("utf-8"), salt.encode("utf-8"))
  
      user = models.User(user_id=user_id,
                         user_type=user_type,
                         username=user_in.username,
                         password=hashed_password.decode("utf-8"),
                         salt=salt)
      db.add(user)
      await db.commit()
      await db.refresh(user)
      return user.id
  
  
  async def create_student(db: AsyncSession, student: schemas.UserIn) -> int:
      db_student = models.Student(
          first_name=student.first_name,
          last_name=student.last_name,
          email=student.email,
      )
      db.add(db_student)
      await db.commit()
      await db.refresh(db_student)
      return db_student.id
  
  
  async def create_tutor(db: AsyncSession, tutor: schemas.UserIn) -> int:
      db_tutor = models.Tutor(
          first_name=tutor.first_name,
          last_name=tutor.last_name,
          email=tutor.email,
      )
      db.add(db_tutor)
      await db.commit()
      await db.refresh(db_tutor)
      return db_tutor.id
  
  
  async def create_solution(db: AsyncSession,
                            student_id: int,
                            lab_variant_id: int,
                            solution_file: Optional[UploadFile]) -> int:
      solution_filename = None
      file_data = None
      if solution_file:
          solution_filename = solution_file.filename
          file_data = await solution_file.read()
  
      solution = models.LabSolution(
          student_id=student_id,
          lab_variant_id=lab_variant_id,
          solution_filename=solution_filename,
          file_data=file_data)
      db.add(solution)
      await db.commit()
      await db.refresh(solution)
      return solution.id
  
  
  async def create_comment(db: AsyncSession,
                           user_id: int,
                           user_type: str,
                           solution_id: int,
                           comment_text: str) -> int:
      comment = models.LabSolutionComment(
          user_id=user_id,
          user_type=user_type,
          solution_id=solution_id,
          comment_text=comment_text)
      db.add(comment)
      await db.commit()
      await db.refresh(comment)
      return comment.id
  
  
  # Get statements
  async def get_user_by_username(db: AsyncSession, username: str):
      stmt = select(models.User).where(models.User.username == username)
      result = await db.execute(stmt)
      return result.scalar_one_or_none()
  
  
  async def get_user_by_id(db: AsyncSession, user_id: int):
      stmt = select(models.User).where(models.User.id == user_id)
      result = await db.execute(stmt)
      return result.scalar_one_or_none()
  
  
  async def verify_password(password: str, salt: str, hashed_password: str) -> bool:
      return bcrypt.checkpw(password.encode("utf-8"), hashed_password.encode("utf-8")) and bcrypt.checkpw(salt.encode("utf-8"), hashed_password.encode("utf-8"))

Contents of schemas.py:
  from typing import Optional
  from fastapi import UploadFile
  from pydantic import BaseModel
  
  
  class UserIn(BaseModel):
      username: str
      password: str
      first_name: str
      last_name: str
      email: str
  
  
  class UserOut(BaseModel):
      user_id: int
      user_type: str
  
  
  class Config:
      orm_mode = True
  
  
  class Token(BaseModel):
      access_token: str
      token_type: str
  
  
  class SolutionUpload(BaseModel):
      lab_variant_id: int
      solution_text: Optional[str]
      solution_file: Optional[UploadFile]  # Import UploadFile from fastapi
  
  
  class SolutionComment(BaseModel):
      solution_id: int
      comment_text: str
